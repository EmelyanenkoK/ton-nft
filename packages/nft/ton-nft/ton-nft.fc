;;
;;  TON NFT Smart Contract
;;

int equal_slices (slice s1, slice s2) asm "SDEQ";
int slice_null?(slice c) asm "ISNULL";

int notification::ownership_assigned() asm "0x11 PUSHINT";
int notification::editorship_assigned() asm "0x14 PUSHINT";
int notification::content_updated() asm "0x13 PUSHINT";
int notification::code_updated() asm "0x16 PUSHINT";

;;
;;  Storage
;;
;;  uint64 index
;;  MsgAddressInt creator
;;  MsgAddressInt collection
;;  MsgAddressInt owner
;;  cell content
;;
;;

_ load_data() impure {
    slice ds = get_data().begin_parse();
    var (index, collection) = (ds~load_uint(64),ds~load_msg_addr());
    if(ds.slice_bits() > 0 ) {
      return (-1, index, collection, ds~load_msg_addr(), ds~load_msg_addr(), ds~load_ref() );
    } else {
      return (0, index, collection, null(), null(), null());
    }
}

() store_data(var ds) impure {
    (int index, slice collection, slice owner, slice editor, cell content) = ds;
    set_data(
        begin_cell()
            .store_uint(index, 64)
            .store_slice(owner)
            .store_slice(editor)
            .store_slice(collection)
            .store_ref(content)
            .end_cell()
    );
}

int gas_to_coins(int workchain, int gas) inline_ref {
  int config_index = 21 + workchain;
  var cs = config_param(config_index).begin_parse();
  if (cs.preload_uint(8) == 0xd1) { ;; gas_flat_pfx
    cs~skip_bits(8 + 64 + 64);
  }
  int tag = cs~load_uint(8);
  throw_unless(71, (tag == 0xdd) | (tag == 0xde)); ;; gas_prices or gas_prices_ext
  int gas_price = cs~load_uint(64);
  return (gas * gas_price) >> 16;
}

;;
;; Serializes
;; addr_std$10 anycast:(Maybe Anycast) workchain_id:int8 address:bits256 = MsgAddressInt;
;; output is 267 bits
;;
slice pack_std_addr(int wc, int addr) {
    return begin_cell()
        .store_uint(2, 2)
        .store_uint(0, 1)
        .store_int(wc, 8)
        .store_uint(addr, 256)
        .end_cell()
        .begin_parse();
}

(int) get_decimal_symbol(int symbol_code) {
  symbol_code -= 48;
  throw_unless(400, (symbol_code < 0) | (symbol_code > 9) );
  return symbol_code;
}

(slice, (int)) ~load_hex_symbol(slice source) {
    int n = source~load_uint(8);
    n = n - 48;
    throw_unless(400, n >= 0);
    if (n < 10) {
        return (source, (n));
    }
    n = n - 7;
    throw_unless(400, n >= 0);
    if (n < 16) {
        return (source, (n));
    }
    n = n - 32;
    throw_unless(400, (n >= 0) & (n < 16));
    return (source, (n));
}

(slice, (int, int)) ~parse_raw_text_address(slice source) {
    int n = source.preload_uint(8);
    var is_negative = n == 0x2d; ;; minus sign
    if is_negative {
      source~skip_bits(8);
    }

    int wc = 0;
    int parsed? = 0;
    ;; Parse workchain id
    while (~ parsed?) {
        int symbol = source~load_uint(8);
        parsed? = symbol == 0x3a;
        if (~ parsed?) {
          wc *= 10;
          wc += get_decimal_symbol(symbol);
        }
    }

    if is_negative {
        wc *= -1;
    }

    ;; Parse address 64 bytes
    int address = 0;
    repeat (64) {
        address = address * 16 + source~load_hex_symbol();
    }

    return (source, (wc, address));
}

() notify (slice to, int op, int amount, int query_id, slice data1, slice data2) impure inline {
  if to.preload_uint(2) == 0 { ;; addr_none: 00
    return ();
  }
  ;; int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 011000
  var msg = begin_cell()
    .store_uint(0x10, 6) ;; nobounce
    .store_slice(to)
    .store_grams(amount)
    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
    .store_uint(op, 32)
    .store_uint(query_id, 64);
  if (data1.slice_null?()) {
    msg = msg.store_slice(data1);
  }
  if (data2.slice_null?()) {
    msg = msg.store_slice(data2);
  }
  return send_raw_message(msg.end_cell(), 1); ;; paying fees, revert on errors
}

() transfer_ownership (slice sender, int query_id, slice new_owner) impure {
    (int init, int index, slice collection, slice owner, slice editor, cell content) = load_data();
    throw_unless(401, equal_slices(sender, owner));
    ;; TODO 20k is too much ??? 0.02 TON at current prices
    ;; TODO only basechain fees? smart-contract nft owners will be forced to be on basechain
    int amount =  gas_to_coins(0, 20000); ;;effectively allows handling up to 65m nfts
    notify(new_owner, notification::ownership_assigned(), amount, query_id, owner, null());
    store_data(index, collection, new_owner, editor, content);
}

() after_code_upgrade(slice data, int query_id) impure {
} 

() edit (slice sender, int query_id, slice payload) impure {
  (int init, int index, slice collection, slice owner, slice editor, cell content) = load_data();
  throw_unless(401, equal_slices(sender, editor));
  int op = payload~load_uint(8);
  int amount =  gas_to_coins(0, 20000);
  if op == 0 {
    content = payload~load_ref();
    notify(editor, notification::content_updated(), amount, query_id, null(), null());
  }
  if op == 1 { ;; transfer editorship
    slice new_editor = payload~load_msg_addr();
    notify(new_editor, notification::editorship_assigned(), amount, query_id, editor, new_editor);
    editor = new_editor;
  }
  if op == 2 {
    cell new_code = payload~load_ref();
    set_code(new_code);
    notify(editor, notification::code_updated(), amount, query_id, null(), null());
    if(payload.slice_refs() > 0) {
      slice post_process = payload~load_ref().begin_parse();
      set_c3(new_code.begin_parse().bless());
      after_code_upgrade(post_process, query_id);
      throw(0);
    }
  }
  store_data(index, collection, owner, editor, content);
}

() handle_comment_message (slice msg_body, slice sender_address) impure {
    ;; For giftTo request one Cell is not enough
    if (msg_body.slice_data_empty?() & (msg_body.slice_refs() == 1)) {
      cell ref_msg = msg_body~load_ref();
      msg_body = ref_msg.begin_parse();
    }

    ;; 'giftTo:'
    int command = msg_body~load_uint(56);
    throw_unless(400, command == 0x67696674546f3a);
    var (int destination_wc, int destination_address) = msg_body~parse_raw_text_address();
    var new_owner_address = pack_std_addr(destination_wc, destination_address);
    return transfer_ownership(sender_address, 0, new_owner_address);
}

() recv_internal(int smc_balance, int msg_value, cell msg, slice msg_body) {
    if (msg_body.slice_empty?()) {
        ;; ignore empty messages
        return ();
    }

    slice cs = msg.begin_parse();
    int flags = cs~load_uint(4);

    ;; ignore all bounced messages
    if (flags & 1) {
        return ();
    }

    var data = load_data();
    (int init?, int index, slice collection, _, _, _) = load_data();
    slice sender_address = cs~load_msg_addr();
    if ~ init? {
      if equal_slices(collection, sender_address) {
        return store_data(index, collection, msg_body~load_msg_addr(), msg_body~load_msg_addr(), msg_body~load_ref());
      } else {
        ;; attempt to deploy from wrong address
        var msg = begin_cell()
          .store_uint(0x10, 6)
          .store_slice(collection)
          .store_grams(0)
          .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1);
        return send_raw_message(msg.end_cell(), 32 + 128);
      }
    }

    int op = msg_body~load_uint(32);

    ;; Message with comment
    if (op == 0) {
        return handle_comment_message(msg_body, sender_address);
    }
    int query_id = msg_body~load_uint(64);
    if (op == 1) { ;; transfer ownership
      slice new_owner = msg_body~load_msg_addr();
      return transfer_ownership(sender_address, query_id, new_owner);
    }
    if (op == 2) { ;; edit
      return edit(sender_address, query_id, msg_body);
    }
}

() recv_external(slice in_msg) {
}

;;
;;  GET Methods
;;

cell get_name() method_id {
	(_, _, _, _, _, cell content) = load_data();
	slice cs = content.begin_parse();
	return cs~load_ref();
}

cell get_symbol() method_id {
    (_, _, _, _, _, cell content) = load_data();
    slice cs = content.begin_parse();
    cs~load_ref();
    return cs~load_ref();
}

int get_index() method_id {
    (_, int index, _, _, _, _) = load_data();
    return index;
}

(int, int) get_collection() method_id {
     (_, _, slice collection, _, _, _) = load_data();
     if collection.slice_bits() == 2 {
       return (0,0);
     }
     return collection.parse_std_addr();
}

(int, int) get_owner() method_id {
     (_, _, _, slice owner, _, _) = load_data();
     return owner.parse_std_addr();
}

cell get_content() method_id {
     (_, _, _, _, _, cell content) = load_data();
     return content;
}

(int, int) get_editor() method_id {
     (_, _, _, _, slice editor, _) = load_data();
     if editor.slice_bits() == 2 {
       return (0,0);
     }
     return editor.parse_std_addr();
}

{- TODO
(int, int) supported_interfaces() method_id {
    ;; 126808: BasicNFT
    ;; 81264: BasicIntrospection
    return (126808, 81264);
}
-}
